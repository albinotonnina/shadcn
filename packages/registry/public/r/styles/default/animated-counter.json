{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "animated-counter",
  "type": "registry:ui",
  "title": "Animated Counter",
  "description": "A number counter with smooth animations, multiple easing options, and viewport detection",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "ui/animated-counter.tsx",
      "type": "registry:ui",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface AnimatedCounterProps\n  extends React.HTMLAttributes<HTMLSpanElement> {\n  /** The target value to count to */\n  value: number;\n  /** Duration of the animation in milliseconds */\n  duration?: number;\n  /** Number of decimal places to show */\n  decimals?: number;\n  /** Prefix to display before the number (e.g., \"$\") */\n  prefix?: string;\n  /** Suffix to display after the number (e.g., \"%\") */\n  suffix?: string;\n  /** Whether to use locale formatting (e.g., 1,000) */\n  useLocale?: boolean;\n  /** Start counting when element is in viewport */\n  startOnView?: boolean;\n  /** Easing function for the animation */\n  easing?: \"linear\" | \"easeOut\" | \"easeInOut\" | \"spring\";\n}\n\nconst easingFunctions = {\n  linear: (t: number) => t,\n  easeOut: (t: number) => 1 - Math.pow(1 - t, 3),\n  easeInOut: (t: number) =>\n    t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,\n  spring: (t: number) => {\n    const c4 = (2 * Math.PI) / 3;\n    return t === 0\n      ? 0\n      : t === 1\n        ? 1\n        : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n  },\n};\n\nconst AnimatedCounter = React.forwardRef<HTMLSpanElement, AnimatedCounterProps>(\n  (\n    {\n      value,\n      duration = 2000,\n      decimals = 0,\n      prefix = \"\",\n      suffix = \"\",\n      useLocale = true,\n      startOnView = true,\n      easing = \"easeOut\",\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const [displayValue, setDisplayValue] = React.useState(0);\n    const [hasStarted, setHasStarted] = React.useState(!startOnView);\n    const elementRef = React.useRef<HTMLSpanElement>(null);\n    const combinedRef = useCombinedRefs(ref, elementRef);\n\n    // Intersection Observer for startOnView\n    React.useEffect(() => {\n      if (!startOnView || !elementRef.current) return;\n\n      const observer = new IntersectionObserver(\n        (entries) => {\n          if (entries[0].isIntersecting) {\n            setHasStarted(true);\n            observer.disconnect();\n          }\n        },\n        { threshold: 0.1 }\n      );\n\n      observer.observe(elementRef.current);\n\n      return () => observer.disconnect();\n    }, [startOnView]);\n\n    // Animation effect\n    React.useEffect(() => {\n      if (!hasStarted) return;\n\n      let startTime: number | null = null;\n      let animationFrame: number;\n      const startValue = displayValue;\n      const easingFn = easingFunctions[easing];\n\n      const animate = (currentTime: number) => {\n        if (!startTime) startTime = currentTime;\n        const elapsed = currentTime - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n        const easedProgress = easingFn(progress);\n\n        const currentValue = startValue + (value - startValue) * easedProgress;\n        setDisplayValue(currentValue);\n\n        if (progress < 1) {\n          animationFrame = requestAnimationFrame(animate);\n        }\n      };\n\n      animationFrame = requestAnimationFrame(animate);\n\n      return () => {\n        if (animationFrame) {\n          cancelAnimationFrame(animationFrame);\n        }\n      };\n    }, [value, duration, hasStarted, easing]);\n\n    const formattedValue = React.useMemo(() => {\n      const rounded =\n        Math.round(displayValue * Math.pow(10, decimals)) /\n        Math.pow(10, decimals);\n      if (useLocale) {\n        return rounded.toLocaleString(undefined, {\n          minimumFractionDigits: decimals,\n          maximumFractionDigits: decimals,\n        });\n      }\n      return rounded.toFixed(decimals);\n    }, [displayValue, decimals, useLocale]);\n\n    return (\n      <span\n        ref={combinedRef}\n        className={cn(\n          \"tabular-nums font-bold text-4xl tracking-tight\",\n          className\n        )}\n        {...props}\n      >\n        {prefix}\n        {formattedValue}\n        {suffix}\n      </span>\n    );\n  }\n);\nAnimatedCounter.displayName = \"AnimatedCounter\";\n\n// Utility hook to combine refs\nfunction useCombinedRefs<T>(\n  ...refs: (React.Ref<T> | undefined)[]\n): React.RefCallback<T> {\n  return React.useCallback(\n    (element: T) => {\n      refs.forEach((ref) => {\n        if (!ref) return;\n        if (typeof ref === \"function\") {\n          ref(element);\n        } else {\n          (ref as React.MutableRefObject<T>).current = element;\n        }\n      });\n    },\n    [refs]\n  );\n}\n\nexport { AnimatedCounter };\n"
    }
  ],
  "tailwind": {
    "config": {}
  },
  "cssVars": {
    "light": {},
    "dark": {}
  }
}
